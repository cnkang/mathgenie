name: ðŸ¤– Dependabot Auto-merge

on:
  pull_request:
    types: [opened, synchronize]

# Only run on Dependabot PRs
concurrency:
  group: dependabot-${{ github.event.pull_request.number }}
  cancel-in-progress: true

# Configurable inputs for timeout and polling
env:
  NODE_VERSION: "22"
  PNPM_VERSION: "10.15.1"
  WAIT_TIMEOUT_MS: 300000 # 5 minutes
  POLL_INTERVAL_MS: 10000 # 10 seconds

jobs:
  # Job 1: Dependabot PR Analysis
  dependabot-analysis:
    name: ðŸ” Dependabot Analysis
    runs-on: ubuntu-latest
    if: github.actor == 'dependabot[bot]'
    timeout-minutes: 10
    permissions:
      contents: read
      pull-requests: write
      issues: write

    outputs:
      auto_merge: ${{ steps.analysis.outputs.auto_merge }}
      update_type: ${{ steps.analysis.outputs.update_type }}

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v5

      - name: ðŸ§¾ Fetch Dependabot metadata
        id: metadata
        uses: dependabot/fetch-metadata@08eff52bf64351f401fb50d4972fa95b9f2c2d1b # v2.4.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ” Analyze Dependabot PR
        id: analysis
        uses: actions/github-script@v7
        env:
          UPDATE_TYPE: ${{ steps.metadata.outputs.update-type }}
          DEPENDENCY_TYPE: ${{ steps.metadata.outputs.dependency-type }}
          PACKAGE_NAMES: ${{ steps.metadata.outputs.dependency-names }}
          SECURITY_SEVERITY: ${{ steps.metadata.outputs.security-advisory-severity }}
          SECURITY_ID: ${{ steps.metadata.outputs.security-advisory-id }}
          ECOSYSTEM: ${{ steps.metadata.outputs.package-ecosystem }}
        with:
          script: |
            const core = require('@actions/core');
            const pr = context.payload.pull_request;

            const updateTypeRaw = process.env.UPDATE_TYPE || 'unknown';
            const dependencyType = process.env.DEPENDENCY_TYPE || 'unknown';
            const dependencyNames = process.env.PACKAGE_NAMES || 'unknown';
            const securitySeverity = process.env.SECURITY_SEVERITY || '';
            const ecosystem = process.env.ECOSYSTEM || 'unknown';

            const updateType = updateTypeRaw.startsWith('version-update:semver-')
              ? updateTypeRaw.replace('version-update:semver-', '')
              : (updateTypeRaw || 'unknown');

            const isDevDependency = dependencyType.includes('development');
            const titleLower = (pr.title || '').toLowerCase();

            let autoMerge = false;
            if (securitySeverity) {
              // Only auto-merge low or moderate severity security updates without breaking changes
              const severityLower = securitySeverity.toLowerCase();
              if (
                (severityLower === 'low' || severityLower === 'moderate') &&
                !titleLower.includes('breaking')
              ) {
                autoMerge = true;
              }
              // For high or critical severity, require manual review (do not auto-merge)
            } else if (updateType === 'patch') {
              autoMerge = true;
            } else if (updateType === 'minor' && isDevDependency) {
              autoMerge = true;
            } else if (updateType === 'minor' && !titleLower.includes('breaking')) {
              autoMerge = true;
            }

            let breakingRisk = 'Low';
            if (securitySeverity) {
              breakingRisk = 'Security';
            } else if (updateType === 'major') {
              breakingRisk = 'High';
            } else if (updateType === 'minor' && !isDevDependency) {
              breakingRisk = 'Medium';
            }

            const labels = ['dependencies', `${updateType}-update`];
            if (isDevDependency) labels.push('dev-dependency');
            if (securitySeverity) labels.push('security-update');
            if (breakingRisk === 'High') labels.push('breaking-change-risk');

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels
            });

            const commentLines = [
              '## ðŸ¤– Dependabot PR Analysis',
              `- **Ecosystem**: \`${ecosystem}\``,
              `- **Package**: \`${dependencyNames}\``,
              `- **Update Type**: ${updateTypeRaw || 'unknown'}`,
              `- **Dependency Type**: ${dependencyType}`,
              `- **Security Severity**: ${securitySeverity || 'N/A'}`,
              `- **Breaking Change Risk**: ${breakingRisk}`,
              `- **Auto-merge Eligible**: ${autoMerge ? 'âœ… Yes' : 'âŒ No'}`
            ];

            if (!autoMerge) {
              commentLines.push('\nâš ï¸ This update needs manual review before merging.');
            } else {
              commentLines.push('\nâœ… This update meets the auto-merge policy.');
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: commentLines.join('\n')
            });

            core.setOutput('update_type', updateType);
            core.setOutput('auto_merge', autoMerge.toString());

  # Job 2: Run CI for Dependabot PRs
  dependabot-ci:
    name: ðŸ§ª Dependabot CI
    runs-on: ubuntu-latest
    needs: dependabot-analysis
    if: github.actor == 'dependabot[bot]'
    timeout-minutes: 20
    permissions:
      contents: read

    steps:
      - name: ðŸ“¥ Checkout code
        uses: actions/checkout@v5

      - name: ðŸ“¦ Setup Node.js & pnpm
        uses: actions/setup-node@v5
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "pnpm"

      - name: ðŸ“¦ Enable pnpm via Corepack
        run: |
          echo "ðŸ”§ Enabling pnpm via Corepack..."
          corepack enable

          echo "ðŸ” Pinning and activating pnpm version via Corepack..."
          corepack prepare pnpm@${{ env.PNPM_VERSION }} --activate

          echo "ðŸ“‹ Final pnpm verification:"
          if ! which pnpm > /dev/null 2>&1; then
            echo "âŒ pnpm not found in PATH after installation attempts"
            exit 1
          fi
          pnpm --version
          echo "âœ… pnpm setup completed successfully"

      - name: ðŸ“‹ Install dependencies
        run: pnpm install --frozen-lockfile

      - name: ðŸ” Run linting
        run: pnpm lint

      - name: ðŸ§ª Run tests
        run: pnpm test:unit

      - name: ðŸ—ï¸ Build application
        run: pnpm build

      - name: ðŸ”’ Security audit
        run: pnpm audit --audit-level moderate
        continue-on-error: true

  # Job 3: Enable auto-merge for eligible PRs
  dependabot-auto-merge:
    name: ðŸ”„ Enable Auto-merge
    runs-on: ubuntu-latest
    needs: [dependabot-analysis, dependabot-ci]
    if: |
      github.actor == 'dependabot[bot]' && 
      needs.dependabot-analysis.outputs.auto_merge == 'true' &&
      needs.dependabot-ci.result == 'success'
    timeout-minutes: 5
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: ðŸ¤– Enable Auto-merge
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const { owner, repo } = context.repo;

            const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
            const WAIT_TIMEOUT_MS = parseInt(process.env.WAIT_TIMEOUT_MS || '300000', 10);
            const POLL_INTERVAL_MS = parseInt(process.env.POLL_INTERVAL_MS || '10000', 10);

            if (
              isNaN(WAIT_TIMEOUT_MS) || WAIT_TIMEOUT_MS <= 0 ||
              isNaN(POLL_INTERVAL_MS) || POLL_INTERVAL_MS <= 0
            ) {
              throw new Error(
                `Invalid WAIT_TIMEOUT_MS (${WAIT_TIMEOUT_MS}) or POLL_INTERVAL_MS (${POLL_INTERVAL_MS}). Both must be positive integers greater than zero.`
              );
            }

            const waitForStableMergeState = async () => {
              const start = Date.now();
              let lastState = 'unknown';
              let lastMergeable = false;

              while (Date.now() - start < WAIT_TIMEOUT_MS) {
                const { data } = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: pr.number
                });

                lastState = (data.mergeable_state || 'unknown').toLowerCase();
                lastMergeable = Boolean(data.mergeable);
                console.log(`mergeable_state=${lastState}, mergeable=${lastMergeable}`);

                if (!['unknown', 'unstable'].includes(lastState)) {
                  return { state: lastState, mergeable: lastMergeable };
                }

                await sleep(POLL_INTERVAL_MS);
              }

              throw new Error(`Timed out waiting for pull request to leave the unstable state (last state: ${lastState}).`);
            };

            let mergeState;
            try {
              mergeState = await waitForStableMergeState();
            } catch (error) {
              throw new Error(`Auto-merge readiness check failed: ${error.message}`);
            }

            if (
              !mergeState.mergeable ||
              ['dirty', 'draft', 'blocked', 'behind'].includes(mergeState.state)
            ) {
              throw new Error(`Pull request is not ready for auto-merge (current state: ${mergeState.state}).`);
            }

            // Add a comment before enabling auto-merge
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: pr.number,
              body: 'ðŸ¤– Enabling auto-merge for this safe dependency update. The PR will be automatically merged once all required checks pass.'
            });

            // Enable auto-merge using GitHub's GraphQL API (more reliable)
            try {
              const mutation = `
                mutation($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) {
                  enablePullRequestAutoMerge(input: {
                    pullRequestId: $pullRequestId,
                    mergeMethod: $mergeMethod,
                    commitHeadline: "${pr.title} (#${pr.number})",
                    commitBody: "Auto-merged by Dependabot workflow after successful CI checks"
                  }) {
                    pullRequest {
                      autoMergeRequest {
                        enabledAt
                        mergeMethod
                      }
                    }
                  }
                }
              `;

              await github.graphql(mutation, {
                pullRequestId: pr.node_id,
                mergeMethod: 'SQUASH'
              });

              console.log('âœ… Auto-merge enabled successfully');

              // Add success comment
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr.number,
                body: 'âœ… Auto-merge enabled! This PR will be automatically merged when all required status checks pass and any required reviews are approved.'
              });

            } catch (error) {
              console.log('âŒ Failed to enable auto-merge:', error.message);

              // Provide detailed error information
              let errorMessage = 'âŒ Failed to enable auto-merge: ' + error.message + '\n\n**Possible reasons:**';

              if (error.status === 422) {
                errorMessage += '\n- Auto-merge is not enabled for this repository';
                errorMessage += '\n- Branch protection rules may prevent auto-merge';
                errorMessage += '\n- PR may have conflicts or failing checks';
                errorMessage += '\n- Repository settings may restrict auto-merge';
              } else if (error.status === 403) {
                errorMessage += '\n- Insufficient permissions to enable auto-merge';
                errorMessage += '\n- Repository may not allow auto-merge for this user';
              } else {
                errorMessage += '\n- Unexpected error occurred';
                errorMessage += '\n- Check repository settings and branch protection rules';
              }

              errorMessage += '\n\n**Next steps:**';
              errorMessage += '\n1. Check if auto-merge is enabled in repository settings';
              errorMessage += '\n2. Verify branch protection rules allow auto-merge';
              errorMessage += '\n3. Ensure all required status checks are configured';
              errorMessage += '\n4. Consider manual merge if auto-merge is not available';
              errorMessage += '\n\n**Manual merge:** You can safely merge this PR manually as it passed all CI checks and was identified as a safe dependency update.';

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr.number,
                body: errorMessage
              });
            }

  # Job 4: Notify on manual review required
  dependabot-manual-review:
    name: ðŸ“¢ Manual Review Required
    runs-on: ubuntu-latest
    needs: [dependabot-analysis, dependabot-ci]
    if: |
      github.actor == 'dependabot[bot]' && 
      needs.dependabot-analysis.outputs.auto_merge == 'false' &&
      needs.dependabot-ci.result == 'success'
    timeout-minutes: 5
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: ðŸ“¢ Request manual review
        uses: actions/github-script@v7
        env:
          UPDATE_TYPE: ${{ needs.dependabot-analysis.outputs.update_type }}
        with:
          script: |
            const pr = context.payload.pull_request;
            const updateType = process.env.UPDATE_TYPE;

            // Request review from maintainers (update with actual GitHub usernames)
            const maintainers = []; // Add actual maintainer usernames here

            try {
              await github.rest.pulls.requestReviewers({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                reviewers: maintainers
              });
            } catch (error) {
              console.log('Could not request reviewers:', error.message);
            }

            // Add comment
            const reviewReason = updateType === 'major' ? 
              'Major version update - may contain breaking changes' :
              updateType === 'minor' ? 
              'Minor version update for production dependency - may introduce new features' :
              'Update requires manual verification';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: `
              ## ðŸ‘€ Manual Review Required
              
              This Dependabot PR requires manual review due to:
              - **Update Type**: ${updateType}
              - **Review Reason**: ${reviewReason}
              
              Please review the changes carefully before merging.
              
              âœ… **CI Status**: All checks passed
              
              **Recommended Actions:**
              ${updateType === 'major' ? 
                '- Review the package changelog for breaking changes\n- Test the application thoroughly\n- Update any affected code' :
                '- Review the package changelog for new features\n- Verify compatibility with existing code'
              }
              `
            });

  # Job 5: Handle CI failures
  dependabot-ci-failure:
    name: âŒ CI Failure Handler
    runs-on: ubuntu-latest
    needs: [dependabot-analysis, dependabot-ci]
    if: |
      github.actor == 'dependabot[bot]' && 
      needs.dependabot-ci.result == 'failure'
    timeout-minutes: 5
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: âŒ Handle CI failure
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: `
              ## âŒ CI Checks Failed
              
              The automated CI checks have failed for this Dependabot PR.
              
              **Next Steps:**
              1. Review the failed checks in the Actions tab
              2. Determine if the failure is related to the dependency update
              3. If it's a legitimate issue, consider:
                 - Updating the dependency manually with fixes
                 - Skipping this update temporarily
                 - Investigating compatibility issues
              
              **Workflow Run**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
              `
            });

            // Add failure label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['ci-failure', 'needs-investigation']
            });

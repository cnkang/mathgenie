#!/usr/bin/env tsx
/**
 * Duplicate string literal finder and fixer (AST-based)
 * - Detects repeated string literals within a file
 * - Optionally injects file-local constants and replaces occurrences
 *
 * Heuristics:
 * - Ignores import/export module specifiers and import type nodes
 * - Ignores strings shorter than minLength
 * - Fix triggers only when occurrence count >= minCount
 */

import { readFileSync, writeFileSync } from 'node:fs';
import * as ts from 'typescript';

export type DuplicateString = {
  text: string;
  count: number;
  line: number;
  preview: string;
  occurrences: Array<{ start: number; end: number; wrapWithBraces: boolean }>;
};

export type FindOptions = {
  minLength: number;
  minCount: number;
};

const DEFAULT_OPTIONS: FindOptions = { minLength: 6, minCount: 3 } as const;
const EXCLUDED_STRINGS = new Set<string>(['undefined']);

function isStringNode(node: ts.Node): node is ts.StringLiteral | ts.NoSubstitutionTemplateLiteral {
  return ts.isStringLiteral(node) || ts.isNoSubstitutionTemplateLiteral(node);
}

function isInImportOrExport(node: ts.Node): boolean {
  let current: ts.Node | undefined = node.parent;
  while (current) {
    if (
      ts.isImportDeclaration(current) ||
      ts.isExportDeclaration(current) ||
      ts.isImportEqualsDeclaration(current)
    ) {
      return true;
    }
    if (ts.isSourceFile(current)) {
      break;
    }
    current = current.parent;
  }
  return false;
}

function isInTypeOrModuleSpecifier(node: ts.Node): boolean {
  let current: ts.Node | undefined = node.parent;
  while (current) {
    if (
      ts.isTypeReferenceNode(current) ||
      ts.isLiteralTypeNode(current) ||
      ts.isImportTypeNode(current)
    ) {
      return true;
    }
    if (ts.isSourceFile(current)) {
      break;
    }
    current = current.parent;
  }
  return false;
}

function computeLineOfPos(sf: ts.SourceFile, pos: number): number {
  const { line } = sf.getLineAndCharacterOfPosition(pos);
  return line + 1;
}

function makeConstName(base: string, used: Set<string>): string {
  // Derive from content: uppercase alnum with underscores
  const cleaned = base
    .trim()
    .slice(0, 80)
    .replace(/\s+/g, '_')
    .replace(/[^A-Za-z0-9_-]/g, '_')
    .replace(/-+/g, '_')
    .replace(/_/g, '_')
    .replace(/^_+/g, '')
    .replace(/_$/g, '')
    .toUpperCase();

  let candidate = cleaned ? `STR_${cleaned}` : 'STR_CONST';
  if (/^\d/.test(candidate)) {
    candidate = `STR_${candidate}`;
  }
  let name = candidate;
  let i = 2;
  while (used.has(name)) {
    name = `${candidate}_${i++}`;
  }
  used.add(name);
  return name;
}

export function findDuplicateStringsInSource(
  source: string,
  filePath = 'inline.tsx',
  options: FindOptions = DEFAULT_OPTIONS
): { duplicates: DuplicateString[] } {
  const sf = ts.createSourceFile(
    filePath,
    source,
    ts.ScriptTarget.Latest,
    true,
    filePath.endsWith('.tsx') ? ts.ScriptKind.TSX : ts.ScriptKind.TS
  );

  // Determine autogenerated constants block range (to ignore duplicates within it)
  let autoStartPos = -1;
  let autoEndPos = -1;
  {
    const startMarker = '// AUTO-GENERATED: duplicate strings extracted by sonar-check --fix';
    const lines = source.split(/\r?\n/);
    const startIdx = lines.findIndex(l => l.includes(startMarker));
    if (startIdx !== -1) {
      let pos = 0;
      for (let i = 0; i < startIdx; i++) pos += lines[i].length + 1;
      autoStartPos = pos;
      let endLine = startIdx + 1;
      while (endLine < lines.length && /^const\s+STR_[A-Z\d_]+\s*=/.test(lines[endLine].trim())) {
          endLine++;
      }
      for (let i = startIdx; i < endLine; i++) pos += lines[i].length + 1;
      autoEndPos = pos;
    }
  }

  const counts = new Map<string, DuplicateString>();

  const visit = (node: ts.Node): void => {
    if (isStringNode(node)) {
      const nodeStart = node.getStart(sf);
      if (autoStartPos !== -1 && autoEndPos !== -1 && nodeStart >= autoStartPos && nodeStart < autoEndPos) {
        // Skip literals inside autogenerated block
        return;
      }
      if (isInImportOrExport(node) || isInTypeOrModuleSpecifier(node)) {
        return;
      }
      const { text } = node as ts.StringLiteralLike;
      if (text.length < options.minLength) {
        return;
      }
      if (EXCLUDED_STRINGS.has(text)) {
        return;
      }

      const start = node.getStart(sf);
      const end = node.getEnd();
      const { parent } = node;
      const wrapWithBraces =
        ts.isJsxAttribute(parent) && parent.initializer != null && parent.initializer == node;
      const item = counts.get(text);
      if (item) {
        item.count += 1;
        item.occurrences.push({ start, end, wrapWithBraces });
      } else {
        counts.set(text, {
          text,
          count: 1,
          line: computeLineOfPos(sf, node.getStart(sf)),
          preview: `'${text}'`,
          occurrences: [{ start, end, wrapWithBraces }],
        });
      }
    }
    ts.forEachChild(node, visit);
  };

  visit(sf);

  const duplicates = Array.from(counts.values()).filter(d => d.count >= options.minCount);
  return { duplicates };
}

export function findDuplicateStringsInFile(
  filePath: string,
  options: FindOptions = DEFAULT_OPTIONS
): { duplicates: DuplicateString[]; source: string } {
  const source = readFileSync(filePath, 'utf8');
  const { duplicates } = findDuplicateStringsInSource(source, filePath, options);
  return { duplicates, source };
}

function removeExistingAutoBlock(source: string): string {
  const startMarker = '// AUTO-GENERATED: duplicate strings extracted by sonar-check --fix';
  const lines = source.split(/\r?\n/);
  const startIdx = lines.findIndex(l => l.includes(startMarker));
  if (startIdx === -1) {
    return source;
  }
  let endIdx = startIdx + 1;
  while (endIdx < lines.length && /^const\s+STR_[A-Z\d_]+\s*=/.test(lines[endIdx].trim())) {
    endIdx++;
  }
  lines.splice(startIdx, endIdx - startIdx);
  return lines.join('\n');
}

function findInsertPosAfterImports(sf: ts.SourceFile): number {
  let lastImportEnd = 0;
  for (const stmt of sf.statements) {
    if (ts.isImportDeclaration(stmt) || ts.isImportEqualsDeclaration(stmt)) {
      lastImportEnd = stmt.getEnd();
      continue;
    }
    // stop at first non-import
    break;
  }
  return lastImportEnd;
}

export function applyDuplicateStringFixesToContent(
  filePath: string,
  source: string,
  options: FindOptions = DEFAULT_OPTIONS
): { updated: string; replacedCount: number; constsAdded: number; constNames: string[] } {
  // Ensure idempotency by removing previous generated block first
  let updated = removeExistingAutoBlock(source);
  const { duplicates } = findDuplicateStringsInSource(updated, filePath, options);
  if (duplicates.length === 0) {
    return { updated, replacedCount: 0, constsAdded: 0, constNames: [] };
  }
  const usedNames = new Set<string>();

  // Prepare replacements
  type Replacement = { start: number; end: number; name: string; wrapWithBraces: boolean };
  const replacements: Replacement[] = [];
  const constDecls: string[] = [];

  for (const d of duplicates) {
    const constName = makeConstName(d.text, usedNames);
    const decl = `const ${constName} = ${JSON.stringify(d.text)} as const;`;
    constDecls.push(decl);
    for (const occ of d.occurrences) {
      replacements.push({
        start: occ.start,
        end: occ.end,
        name: constName,
        wrapWithBraces: occ.wrapWithBraces,
      });
    }
  }

  // Sort by start DESC to avoid shifting positions
  replacements.sort((a, b) => b.start - a.start);

  // Apply token-level replacements on the current updated string using original positions.
  for (const r of replacements) {
    const replacementText = r.wrapWithBraces ? `{${r.name}}` : r.name;
    updated = updated.slice(0, r.start) + replacementText + updated.slice(r.end);
  }

  // Re-parse to compute a safe insertion point after imports
  const sf2 = ts.createSourceFile(
    filePath,
    updated,
    ts.ScriptTarget.Latest,
    true,
    filePath.endsWith('.tsx') ? ts.ScriptKind.TSX : ts.ScriptKind.TS
  );
  const insertPos = findInsertPosAfterImports(sf2);
  const header =
    '\n\n// AUTO-GENERATED: duplicate strings extracted by sonar-check --fix\n// Do not edit manually.\n';
  const constBlock = constDecls.join('\n') + '\n';

  const before = updated.slice(0, insertPos);
  const after = updated.slice(insertPos);
  updated = before + header + constBlock + after;

  // Post-process: ensure JSX attributes using bare identifiers are wrapped with braces
  if (filePath.endsWith('.tsx')) {
    // Only within JSX tag attribute lists: capture up to attribute, keep tag prefix intact
    const jsxAttrBareIdInTag =
      /(<[^>]*?\b)([A-Za-z_:][A-Za-z\d_:.-]*\s*=)\s*(STR_[A-Z\d_]+)(?![A-Za-z\d_])/g;
    updated = updated.replace(
      jsxAttrBareIdInTag,
      (_m, p0: string, p1: string, p2: string) => `${p0}${p1}{${p2}}`
    );
    // Repair accidental braces on DOM property assignments (not JSX)
    const domClassNameBrace = /(\.className\s*=)\s*{(STR_[A-Z0-9_]+)}/g;
    updated = updated.replace(domClassNameBrace, (_m, p1: string, p2: string) => `${p1} ${p2}`);
  }

  return {
    updated,
    replacedCount: replacements.length,
    constsAdded: constDecls.length,
    constNames: constDecls.map(d =>
      d
        .split('=')[0]
        .trim()
        .replace(/^const\s+/, '')
    ),
  };
}

export function applyDuplicateStringFixesToFile(
  filePath: string,
  options: FindOptions = DEFAULT_OPTIONS
): { changed: boolean; replacedCount: number; constsAdded: number } {
  const input = readFileSync(filePath, 'utf8');
  const res = applyDuplicateStringFixesToContent(filePath, input, options);
  if (res.updated !== input) {
    writeFileSync(filePath, res.updated, 'utf8');
    return { changed: true, replacedCount: res.replacedCount, constsAdded: res.constsAdded };
  }
  // Even if duplicates were not found, ensure JSX repair in case of previous runs
  if (filePath.endsWith('.tsx')) {
    const jsxAttrBareIdInTag =
      /(<[^>]*?\b)([A-Za-z_:][A-Za-z\d_:.-]*\s*=)\s*(STR_[A-Z\d_]+)(?![A-Za-z\d_])/g;
    let repaired = input.replace(
      jsxAttrBareIdInTag,
      (_m, p0: string, p1: string, p2: string) => `${p0}${p1}{${p2}}`
    );
    const domClassNameBrace = /(\.className\s*=)\s*{(STR_[A-Z0-9_]+)}/g;
    repaired = repaired.replace(domClassNameBrace, (_m, p1: string, p2: string) => `${p1} ${p2}`);
    if (repaired !== input) {
      writeFileSync(filePath, repaired, 'utf8');
      return { changed: true, replacedCount: 0, constsAdded: 0 };
    }
  }
  return { changed: false, replacedCount: 0, constsAdded: 0 };
}
